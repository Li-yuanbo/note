## 2. sync.map

golang官方的原生map是不支持并发读写的，直接并发的读写很容易触发panic。解决的办法有两个：

- 使用锁（sync.Mutex）或读写锁（sync.RWMutex）配合map

- 使用Go 语言在 2017 年发布的 Go 1.9 中正式加入了并发安全的字典类型sync.Map

### 2.1 核心思想&架构

如果要保证并发的安全，最朴素的想法就是使用锁，但这意味着要把并发的操作强制串行化，性能自然就会下降。

除了使用锁，使用原子操作（atomic）也可以达到类似并发安全的目的。

sync.Map的设计非常巧妙，充分利用了atmoic和mutex的配合。

#### 2.1.1 1. 核心思想

**核心原则就是，尽量使用原子操作，最大程度上减少了锁的使用，从而接近了“lock free"的效果。**

核心点：

- 使用了两个原生的map作为存储介质，分别是read map和dirty map（只读字典和脏字典）
- 只读字典使用atomic.Value来承载，保证原子性和高性能；脏字典则需要用互斥锁来保护，保证了互斥
- 只读字典和脏字典中的键值对集合并不是实时同步的，它们在某些时间段内可能会有不同
- 无论是read还是dirty，本质上都是map[interface{}]*entry类型，这里的entry其实就是Map的value的容器
- entry的本质，是一层封装，可以表示具体值的指针，也可以表示key已删除的状态（即逻辑假删除）
- 通过这种设计，规避了原生map无法并发安全delete的问题，同时在变更某个键所对应的值的时候，就也可以使用原子操作了