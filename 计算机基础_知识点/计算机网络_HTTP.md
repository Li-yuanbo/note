HTTP 协议一般指 HTTP（超文本传输协议）。

超文本传输协议（英语：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议，是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。

HTTP 是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。基于 TCP/IP 通信协议来传递数据的（HTML 文件、图片文件、查询结果等）。

### 1. HTTP报文结构

对于 TCP 而言，在传输的时候分为两个部分：**TCP头**和**数据部分**。

而 HTTP 类似，也是`header + body`的结构：

- 起始行 + 头部 + 空行 + 实体

 使用空行用来区分开`Header`和`Body。 

#### 1.1 起始行

**请求报文**

```java
GET /home HTTP/1.1
```

也就是**方法 + 路径 + http版本**

在起始行中，每两个部分之间用**空格**隔开，最后一个部分后面应该接一个**换行**，严格遵循`ABNF`语法规范。

**响应报文**

```java
HTTP/1.1 200 OK
```

响应报文的起始行也叫做`状态行`。由**http版本、状态码和返回描述**三部分组成。

#### 1.2 头部

 请求头在报文中的位置：

<img src="./pic/HTTP_1.png" style="zoom:50%;" />

响应头在报文中的位置:：

<img src="./pic/HTTP_2.png" style="zoom:50%;" />

头部字段的格式如下：

- 字段名不区分大小写
- 字段名不允许出现空格，不可以出现下划线`_`
- 字段名后面必须**紧接着`:`**

### 2. HTTP的请求方法

`http/1.1`规定了以下请求方法：

- GET：通常用来获取资源
- HEAD：获取资源的元信息
- POST：提交数据，即上传数据
- PUT：修改数据
- DELETE：删除资源(几乎用不到)
- CONNECT：建立连接隧道，用于代理服务器
- OPTIONS：列出可对资源实行的请求方法，用来跨域请求
- TRACE：追踪请求-响应的传输路径

#### 2.1 GET和POST的区别

- 语义的区别

- **缓存**：GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会
- **编码**：GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制
- **参数**：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息
- **幂等性**：`GET`是**幂等**的，而`POST`不是
- **TCP**：GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应100(continue)， 然后发 body 部分

### 3. URI

**URI**, 全称为(Uniform Resource Identifier), 也就是**统一资源标识符**，作用就是区分互联网上不同的资源。

但是，它并不是我们常说的`网址`，网址指的是`URL`，实际上`URI`包含了`URN`和`URL`两个部分。

#### 3.1 URI的结构

URI 真正最完整的结构如下图：

<img src="./pic/HTTP_3.png" style="zoom:50%;" />

- **scheme** 表示协议名，比如`http`, `https`, `file`等等。后面必须和`://`连在一起

- **user:passwd**@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用

- **host:port**表示主机名和端口

- **path**表示请求路径，标记资源所在位置

- **query**表示查询参数，为`key=val`这种形式，多个键值对之间用`&`隔开

- **fragment**表示 URI 所定位的资源内的一个**锚点**，浏览器可以根据这个锚点跳转到对应的位置。

#### 3.2 URI 编码

URI 只能使用`ASCII`，ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。

因此，URI 引入了`编码`机制，将所有**非 ASCII 码字符**和**界定符**转为十六进制字节值，然后在前面加个`%`。

如，空格被转义成了`%20`，**三元**被转义成了`%E4%B8%89%E5%85%83`。

### 4. HTTP 状态码

 HTTP 的状态码为**三位数**，被分为五类:

- **1xx**: 表示目前是协议处理的中间状态，还需要后续操作
- **2xx**: 表示成功状态
- **3xx**: 重定向状态，资源位置发生变动，需要重新请求
- **4xx**: 请求报文有误
- **5xx**: 服务器端发生错误

#### 4.1 1xx

**101 Switching Protocols**

在`HTTP`升级为`WebSocket`的时候，如果服务器同意变更，就会发送状态码 101。

#### 4.2 2xx

**200 OK**

表示成功的状态码。通常在响应体中包含服务器返回数据

**204 No Content**

含义与 200 相同，但响应头后没有 body 数据

**206 Partial Content**

表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段`Content-Range`

#### 4.3 3xx

**301 Moved Permanently**

永久重定向

**302 Found**

临时重定向

比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回`301`，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。

而如果只是暂时不可用，那么直接返回`302`即可，和`301`不同的是，浏览器并不会做缓存优化。

**304 Not Modified**:

缓存命中时返回这个状态码

#### 4.4 4xx

**400 Bad Request**:

错误的请求，前端请求存在错误

**403 Forbidden**:

服务器禁止访问

**404 Not Found**:

资源未找到，表示没在服务器上找到相应的资源

**405 Method Not Allowed**

请求方法不被服务器端允许

**406 Not Acceptable**

资源无法满足客户端的条件

**408 Request Timeout**

服务器等待了太长时间

**409 Conflict**

多个请求发生了冲突

**413 Request Entity Too Large**

请求体的数据过大

**414 Request-URI Too Long**

请求行里的 URI 太大

**429 Too Many Request**

客户端发送的请求过多

**431 Request Header Fields Too Large**

请求头的字段内容太大

#### 4.5 5xx

**500 Internal Server Error**

服务器出错

**501 Not Implemented**

表示客户端请求的功能还不支持

**502 Bad Gateway**

服务器自身是正常的，但访问的时候出错了

**503 Service Unavailable**

服务器暂时无法处理客户端的请求

### 5. HTTP 特点及缺点

#### 5.1 HTTP 特点

1. 灵活可扩展

- 语义上的自由，只规定了基本格式，如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制

- 传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便

2. 可靠传输

   HTTP 基于 TCP/IP，因此把这一特性继承了下来

3. 请求和应答一一对应

   也就是`一发一收`、`有来有回`， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演**请求方**的角色

4. 无状态

   指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息

#### 5.2 HTTP 缺点

1. 无状态

需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点

2. 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式

这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利

3. 队头阻塞问题

当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的**队头阻塞**问题

### 6.  Accept 系列字段

`Accept`系列字段分为四个部分: **数据格式**、**压缩方式**、**支持语言**和**字符集**。

#### 6.1 数据格式

**MIME**(Multipurpose Internet Mail Extensions, **多用途互联网邮件扩展**)：它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。

HTTP 从**MIME type**取了一部分来标记报文 body 部分的数据类型，这些类型体现在`Content-Type`这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用`Accept`字段。

具体而言，这两个字段的取值可以分为下面几类:

- text： text/html, text/plain, text/css 
- image: image/gif, image/jpeg, image/png 
- audio/video: audio/mpeg, video/mp4 
- application: application/json, application/javascript, application/pdf, application/octet-stream

#### 6.2 压缩方式

一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的`Content-Encoding`字段上， 同样的，接收什么样的压缩方式体现在了接收方的`Accept-Encoding`字段上。这个字段的取值有下面几种：

- gzip: 当今最流行的压缩格式
- deflate
- br: 一种专门为 HTTP 发明的压缩算法

```
// 发送端
Content-Encoding: gzip
// 接收端
Accept-Encoding: gzip
```

#### 6.3 支持语言

对于发送方而言，还有一个`Content-Language`字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为`Accept-Language`。如:

```
// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en
```

#### 6.4 字符集

字符集是一个比较特殊的字段, 在接收端对应为`Accept-Charset`，指定可以接受的字符集，而在发送端并没有对应的`Content-Charset`, 而是直接放在了`Content-Type`中，以**charset**属性指定。如:

```
// 发送端
Content-Type: text/html; charset=utf-8
// 接收端
Accept-Charset: charset=utf-8
```

<img src="./pic/HTTP_4.png" style="zoom:50%;" />

### 7. HTTP怎么传输定长和不定长的数据

#### 7.1 定长包体

对于定长包体而言，发送端在传输的时候一般会带上 `Content-Length`, 来指明包体的长度。

#### 7.2 不定长包体

对于`不定长包体`而言，需要使用一个 http 头部字段：

```
Transfer-Encoding: chunked
```

该头部表示分块传输数据，设置这个字段后会自动产生两个效果:

- Content-Length 字段会被忽略
- 基于长连接持续推送动态内容

### 8. HTTP 数据分段

HTTP 针对这一场景，采取了`范围请求`的解决方案，允许客户端仅仅请求一个资源的一部分。

前提是服务器要支持**范围请求**，要支持这个功能，就必须加上这样一个响应头:

```
Accept-Ranges: none
```

用来告知客户端这边是支持范围请求的。

而对于客户端而言，它需要指定请求哪一部分，通过`Range`这个请求头字段确定，格式为`bytes=x-y`

- **0-499**表示从开始到第 499 个字节
- **500**- 表示从第 500 字节到文件终点
- **-100**表示文件的最后100个字节

服务器收到请求之后，首先验证范围**是否合法**，如果越界了那么返回`416`错误码，否则读取相应片段，返回`206`状态码。

同时，服务器需要添加`Content-Range`字段，这个字段的格式根据请求头中`Range`字段的不同而有所差异。

具体来说，请求`单段数据`和请求`多段数据`，响应头是不一样的。

**单段数据**

```shell
// 请求字段
Range: bytes=0-9

// 响应字段
Content-Range: bytes 0-9/100
```

**多段数据**

```shell
// 请求字段
Range: bytes=0-9, 30-39

// 响应字段
// 标识请求多段数据和响应分割符00000010101
Content-Type: multipart/byteranges; boundary=00000010101  

--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96
```

### 9. HTTP 中如何处理表单数据的提交

在 http 中，有两种主要的表单提交的方式，体现在两种不同的`Content-Type`取值:

- application/x-www-form-urlencoded
- multipart/form-data

由于表单提交一般是`POST`请求，很少考虑`GET`，因此这里我们将默认提交的数据放在请求体中。

#### 9.1 application/x-www-form-urlencoded

对于`application/x-www-form-urlencoded`格式的表单内容，有以下特点:

- 其中的数据会被编码成以`&`分隔的键值对
- 字符以**URL编码方式**编码。

如：

```
// 转换过程: 
{a: 1, b: 2} -> a=1&b=2 -> (最终形式)"a%3D1%26b%3D2"
```

#### 9.2 multipart/form-data

对于`multipart/form-data`而言:

- 请求头中的`Content-Type`字段会包含`boundary`，且`boundary`的值有浏览器默认指定。例: `Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`。
- 数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如`Content-Type`，在最后的分隔符会加上`--`表示结束。

相应的`请求体`是下面这样:

```
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
复制代码
```

`multipart/form-data` 格式最大的特点在于:**每一个表单元素都是独立的资源表述**。在实际的场景中，对于图片等文件的上传，基本采用`multipart/form-data`而不用`application/x-www-form-urlencoded`，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。

### 10. HTTP 队头阻塞问题

#### 10.1 什么是 HTTP 队头阻塞？

HTTP 传输是基于`请求-应答`的模式进行的，报文必须是一发一收，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`HTTP队头阻塞`问题。

#### 10.2 并发连接

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

#### 10.3 域名分片

一个域名可以并发 6 个长连接，可以采取多域名来提高并发。

这样一个域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

### 11. Cookie

#### 11.1 Cookie

HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，HTTP 为此引入了 Cookie。

Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的`Set-Cookie`字段来对客户端写入`Cookie`。举例如下:

```
// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx
```

#### 11.2 Cookie 属性

**生存周期**

Cookie 的有效期可以通过**Expires**和**Max-Age**两个属性来设置。

- **Expires**即`过期时间`
- **Max-Age**用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。

**作用域**

关于作用域也有两个属性: **Domain**和**path**, 给 **Cookie** 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。对于路径来说，`/`表示域名下的任意路径都允许使用 Cookie。

**安全相关**

如果带上`Secure`，说明只能通过 HTTPS 传输 cookie。

如果 cookie 字段带上`HttpOnly`，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。

对于 CSRF 攻击的预防，也有`SameSite`属性。`SameSite`可以设置为三个值，`Strict`、`Lax`和`None`。

- `Strict`模式下，浏览器完全禁止第三方请求携带Cookie。比如请求`sanyuan.com`网站只能在`sanyuan.com`域名当中请求才能携带 Cookie，在其他网站请求都不能

- `Lax`模式，就宽松一点了，只能在 `get方法提交表单`况或者`发送 get 请求`的情况下可以携带 Cookie，其他情况均不能

- `None`模式下，也就是默认模式，请求会自动携带上 Cookie

#### 11.3 Cookie 的缺点

1. 容量缺陷

   Cookie 的体积上限只有`4KB`，只能用来存储少量的信息。

2. 性能缺陷

   Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过`Domain`和`Path`指定**作用域**来解决。

3. 安全缺陷

   由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

### 12. HTTP 代理

HTTP 是基于`请求-响应`模型的协议，一般由客户端发请求，服务器来进行响应。

当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有**双重身份**。

#### 12.1 功能

1. **负载均衡**

   客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括**随机算法**、**轮询**、**一致性hash**、**LRU**等

2. **保障安全**

   利用**心跳**机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作

3. **缓存代理**

   将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里

#### 12.2 相关头部字段

**Via**

代理服务器需要标明自己的身份，在 HTTP 传输中通过`Via`字段来记录。

举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:

```
客户端 -> 代理1 -> 代理2 -> 源服务器
```

在源服务器收到请求后，会在`请求头`拿到这个字段:

```shell
Via: proxy_server1, proxy_server2
```

而源服务器响应时，客户端会拿到这样的`响应头`:

```shell
Via: proxy_server2, proxy_server1
```

可以看到，`Via`中代理的顺序即为在 HTTP 传输中报文传达的顺序。

**X-Forwarded-For**

记录的是**请求方**的`IP`地址(和`Via`区分开，`X-Forwarded-For`记录的是请求方这一个IP)

**X-Real-IP**

获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP

相应的，还有`X-Forwarded-Host`和`X-Forwarded-Proto`，分别记录**客户端**(不包括代理)的`域名`和`协议名`

**X-Forwarded-For产生的问题**

前面可以看到，`X-Forwarded-For`这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从`客户端`到`代理1`，这个字段是客户端的 IP，从`代理1`到`代理2`，这个字段就变为了代理1的 IP。

会产生两个问题:

1. 意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降
2. 在 HTTPS 通信加密的过程中，原始报文是不允许修改的

由此产生了`代理协议`，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:

```
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
```

这样就可以解决`X-Forwarded-For`带来的问题了

### 13. HTTP 缓存及缓存代理

#### 13.1 强缓存和协商缓存

可以通过 `Cache-Control` 验证强缓存是否可用

- 如果强缓存可用，直接使用
- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match这些条件请求字段检查资源是否更新
  - 若资源更新，返回资源和200状态码
  - 否则，返回304，告诉浏览器直接从缓存获取资源

#### 13.2 **代理缓存**

对于源服务器来说，也是有缓存的，比如**Redis, Memcache**，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。

由此引入了**缓存代理**的机制。让`代理服务器`接管一部分的服务端HTTP缓存，客户端缓存过期后**就近**到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。

总的来说，缓存代理的控制分为两部分：

- **源服务器**端的控制
- **客户端**的控制

#### 13.3 源服务器的缓存控制

**private 和 public**

在源服务器的响应头中，会加上`Cache-Control`这个字段进行缓存控制字段，那么它的值当中可以加入`private`或者`public`表示是否允许代理服务器缓存，前者禁止，后者为允许。

比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的`Cache-Control`设为`private`，而不是`public`。

**proxy-revalidate**

`must-revalidate`的意思是**客户端**缓存过期就去源服务器获取，而`proxy-revalidate`则表示**代理服务器**的缓存过期后到源服务器获取。

**s-maxage**

`s`是`share`的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的`max-age`并不冲突。

如：源服务器在响应头中加入这样一个字段

```shell
Cache-Control: public, max-age=1000, s-maxage=2000
```

相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。

#### 13.4 客户端的缓存控制

**max-stale 和 min-fresh**

在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行**宽容**和**限制**操作。

如：**max-stale: 5**

表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在**5秒之内**，还是可以从代理中获取的。

如：**min-fresh: 5**

表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在**到期前 5 秒**之前的时间拿，否则拿不到

**only-if-cached**

这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回`504（Gateway Timeout）`

### 14. 什么是跨域

在前后端分离的开发模式中，经常会遇到跨域问题，即 请求发送成功，服务器响应成功，前端却拿不到响应。

#### 14.1 跨域

<img src="./pic/HTTP_3.png" style="zoom:50%;" />

浏览器遵循**同源政策**(`scheme(协议)`、`host(主机)`和`port(端口)`都相同则为`同源`)。非同源站点有这样一些限制:

- 不能读取和修改对方的 DOM
- 不读访问对方的 Cookie、IndexDB 和 LocalStorage
- 限制 XMLHttpRequest 请求

当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为`跨域请求`。

跨域请求的响应一般会被浏览器所拦截：

服务端处理完数据后，将响应返回，主进程检查到跨域，且没有cors响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。

